>主题：[[Python 数据结构和算法]]

## 数组

数组存储相同类型的数据，并且数组中的每个元素都被存储在连续的内存中。存储相同类型的多个值，这种存储方式使得我们更容易使用**偏移量**（offset）和**基地址**（base address）计算数组中元素的位置。基地址是指存储第一个元素的内存地址。偏移量是一个整数，表示第一个元素和给定元素之间的位移

与列表相比，存储、遍历和访问数组元素更快，因为元素可以使用索引进行随机访问。然而，如果存储在数组中的数据很大并且系统内存不足，数组可能不是一个存储数据的良好选择。此外，数组在创建时需要声明静态大小

与链表相比，数组的插入和删除操作速度较慢。这是因为在数组指定位置插入元素，必须移动该位置后的所有元素，删除元素时也需要进行相应的移动操作。因此，数组适合需要频繁进行元素访问、较少插入和删除操作的情况，而链表适合列表大小不固定，需要进行大量插入和删除操作的应用场景

## 介绍链表

链表的特性：
- 存储在内存中不同位置的元素通过指针连接。指针是一种可以存储变量地址的对象。每个元素都包含一个指针，指向下一个元素，最后一个元素的指针指向 `None`
- 列表的长度可以在程序执行期间增加或减少

链表将数据项存储在内存中的不同位置，这样的一个数据项称为一个节点（node）。节点存储实际的数据和指针

![[Pasted image 20231113183343.png | 450]]

### 节点和指针

节点是一个容器，包含数据和指向其它节点的一个或多个指针。节点实际上并不存储数据本身，而是存储数据的地址


## 单链表

单链表包含多个节点，每个节点包含数据和指向下一个节点的指针，最后一个节点指向 `None`

![[Pasted image 20231113190049.png | 650]]

### 创建和遍历

节点类
```python
class Node: 
    def __init__(self, data=None):  
        self.data = data  
        self.next = None
```
创建 3 个节点并将它们连接起来
```python
n1 = Node('eggs')  
n2 = Node('ham')  
n3 = Node('spam')  
  
n1.next = n2  
n2.next = n3
```
遍历链表
```python
current = n1  
while current:  
    print(current.data)  
    current = current.next
```
输出结果如下：
```python
eggs
ham
spam
```

#### 改进链表遍历

重写 `__iter__` 方法，该方法返回一个生成器
```python
class SinglyLinkedList:
	def __init__(self):
	...
	
	def append(self, data):
	...
	
	def __iter__(self):  
	    current = self.head  
	    while current:  
	        yield current.data  
	        current = current.next
```
遍历链表
```python
for word in words:  
    print(word)
```

### 添加元素

#### 追加元素

`append` 方法
```python
class SinglyLinkedList:
    def __init__(self):  
        self.head = None  
  
    def append(self, data):
        node = Node(data)
        if self.head is None:
            self.head = node
            return

        current = self.head
        while current.next:
            current = current.next
        current.next = node
```
如果链表为空，则新节点将成为头节点。否则，将尾节点的 `next` 指针指向新节点

在这种情况下，我们必须遍历整个链表才能找到插入点。如果链表中只有几个元素，这可能不是问题。然而，当列表很长时，效率会非常低，因为每次追加元素必须遍历整个链表

改进的方法是除了引用链表的第一个节点外，还引用链表的尾节点。改进的代码如下：
```python
class SinglyLinkedList:  
    def __init__(self):  
        self.head = None  
        self.tail = None

	def append(self, data):  
	    node = Node(data)  
	    if self.tail:  
	        self.tail.next = node  
	        self.tail = node  
	    else:  
	        self.tail = node  
	        self.head = node
```

#### 插入元素

![[Pasted image 20231113221808.png]]
在两个节点之间插入一新个节点，需要更新两个链接，前一个节点指向新节点，新节点指向后一个节点
```python
class SinglyLinkedList:  
    def __init__(self):  
        self.head = None  
        self.tail = None

	def insert(self, data, index):  
	    node = Node(data)  
	    if index == 1:  
	        node.next = self.head  
	        self.head = node  
	        return  
	        
	    prev = None  
	    current = self.head  
	    count = 1  
	    while current:  
	        if count == index:  
	            prev.next = node  
	            node.next = current  
	            return  
	        count += 1  
	        prev = current  
	        current = current.next  
	    if count > index:  
	        print(f'index out of range!')
```

### 删除元素

#### 删除首节点

头指针指向首节点的下一个节点
```python
def delete_first_node(self):
	if self.head is None:
		print(f'Empty linked list.')
		return

	if self.head == self.tail:
		self.head = None
		self.tail = None
		return

	self.head = self.head.next
```

#### 删除尾节点

- 倒数第二个节点成为新的尾节点
- `tail` 指针指向新的尾节点
```python
def delete_last_node(self):
	if self.tail is None:
		print(f'Empty linked list.')
		return

	if self.head == self.tail:
		self.head = None
		self.tail = None
		return

	current = self.head
	while current.next is not self.tail:
		current = current.next
	current.next = None
	self.tail = current
```

#### 删除中间节点

通过节点的数据查找节点并删除
```python
    def delete(self, data):
        if self.tail is None:
            print(f'Empty linked list.')
            return

        if self.head is self.tail:
            self.head = None
            self.tail = None

        prev = self.head
        current = self.head
        while current:
            if current.data == data:
                prev.next = current.next
                return
            prev = current
            current = current.next
```

## 双链表

在双链表中有两个指针，一个指向下一个节点，另一个指向前一个节点

![[Pasted image 20231119135858.png|450]]


双链表可以沿任意方向遍历，双链表中的节点可以直接通过指向前一个节点的指针引用


### 创建和遍历

```python
class Node:  
    def __init__ (self, data=None, next=None, prev=None):  
        self.data = data  
        self.next = next  
        self.prev = prev  
  
class DoublyLinkedList:  
    def __init__ (self):  
        self.tail = None  
        self.head = None
```

### 添加元素

#### 开头插入元素

- 新节点的 `next` 指针指向当前的头节点
- 当前头节点的 `prev` 指针指向新节点
- 新节点成为的头节点
```python
def append_at_start(self, data):
	new_node = Node(data)
	if self.head is None:
		self.head = new_node
		self.tail = new_node
		return

	new_node.next = self.head
	self.head.prev = new_node
	if new_node.next is None:
		self.tail = new_node
	self.head = new_node   
```

#### 追加元素

- 新节点的 `prev` 指针指向尾节点
- 尾节点的 `next` 指针指向新节点
- 新节点成为新的尾节点
```python
def append(self, data):
	new_node = Node(data)
	if self.head is None:
		self.head = new_node
		self.tail = new_node
		return 

	new_node.prev = self.tail
	self.tail.next = new_node
	self.tail = new_node
```

#### 插入元素

![[Pasted image 20231119151614.png]]
- 新节点的 `next` 指针指向 current 节点
- 新节点的 `prev` 指针指向 previous 节点
- previous 节点的 `next` 指针指向新节点
- current 节点的 `prev` 指针指向新节点
```python
def insert(self, data):
	new_node = Node(data)
	if self.head is None:
		self.head = new_node
		self.tail = new_node
		return

	prev = self.head
	current = self.head.next
	while current:
		if prev.data == data:
			prev.next = new_node           
			new_node.prev = current         
			current.prev = new_node
			new_node.next = current
			break
		prev = current
		current = current.next
```

### 删除元素

- 要删除的节点在开头时，将 `head` 指针指向下一个节点
- 要删除的节点在末尾时，将 `tail` 指针指向倒数第二个节点
- 要删除的节点在任意中间位置时，将要删除节点的前一个节点指向要删除节点的下一个节点
```python
def delete(self, data):
	current = self.head
	node_deleted = False

	if current is None:
		print("empty linked list.")

	if self.head.data == data:
		self.head = self.head.next
		self.head.prev = None
		node_deleted = True

	if self.tail.data == data:
		self.tail = self.tail.prev
		self.tail.next = None
		node_deleted = True

	while current:
		if current.data == data:
			current.prev.next = current.next
			current.next.prev = current.prev
			node_deleted = True
		current = current.next

	if node_deleted == False:
		print("Item not found")
```


## 循环链表

在循环列表中，最后一个节点指向第一个结点，意味着没有节点指向 `None`

基于单链表的循环链表
![[Pasted image 20231119203352.png|550]]

基于双链表的循环链表
![[Pasted image 20231119203431.png|550]]


### 创建和遍历

```python
class CircularList:
    def __init__ (self):
        self.head = None
        self.tail = None
```

遍历
```python
counter = 0
for word in words:
    print(word)
    counter += 1
    if counter > 2:
        break
```


### 添加元素

- 最后一个节点的 `next` 指针指向新节点
- 新节点的 `next` 指针指向第一个节点
- 更新 `tail` 指针
```python
    def append(self, data):
        node = Node(data)
        if self.tail:
            self.tail.next = node
            self.tail = node
            self.tail.next = self.head
        else:                   # 链表为空
            self.head = node
            self.tail = node
            self.tail.next = self.head
```

### 删除元素

- 要删除的元素在开头时，第二个节点成为新的头节点，最后一个节点指向新的头节点
- 要删除的元素在末尾时，倒数第二个节点成为新的尾节点，新的尾节点指向头节点
- 要删除的元素在中间任意位置时，将要删除节点的前一个节点指向要删除节点的下一个节点
```python
def delete(self, data):
	current = self.head
	prev = self.head
	flag = False
	while current == prev or prev != self.tail:
		if current.data == data:
			flag = True
			# 删除头节点
			if current == self.head:
				self.head = current.next
				self.tail.next = self.head
				return
			# 删除尾结点
			if current == self.tail:
				self.tail = prev
				prev.next = self.head
				return
			# 删除中间节点
			prev.next = current.next
		prev = current
		current = current.next 
	if flag is False:
		print(f'Item {data} not found in the list')
```

>[!note]
>- 节省内存空间，使用单链表
>- 搜搜操作很频繁，使用双链表
>- 遍历操作很频繁，使用循环链表








